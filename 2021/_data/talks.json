{
  "items": [
    {
      "id": "60c112eb3be4300877923156",
      "title": "Integración Kontinua y entrega con Kubernetes",
      "languages": [
        "es"
      ],
      "abstract": "Kubernetes ha madurado suficiente hasta convertirse en la plataforma de orquestación por excelencia, sin embargo aún le falta una un elemento crucial. Y esto hace que Integración Continua y despliegue sean menos efectivas.\nEl mercado ofrece varias soluciones para resolverlo, pero el 99% fallan al no ser nativas para Kuberntes.\n\nEn esta sesión, Alex nos explicará Tekton, la solución nativa Kubernetes para definir y ejecutar tu CI/CD. La sessión explora las características de Tekton y ArgoCD; Cloud Native, Desacoplados y Declarativos.\nJunto a demos en vivo se mostrará como encajar las diferentes piezas de Tekton para hacer tus builds in-cluster, y ArgoCD para desplegar tus aplicaciones Kubernetes.",
      "type": "talk",
      "tags": [
        "kubernetes",
        "continuous delivery"
      ],
      "level": "middle",
      "speakers": [
        "1cf43210c8515585e52e4d2f6f2e5e0f582049d8"
      ]
    },
    {
      "id": "60c113223be4300877923157",
      "title": "Los desarrolladores no necesitan Kubernetes",
      "languages": [
        "es"
      ],
      "abstract": "Desde la aparición de Kubernetes, esperábamos que los desarrolladores lo adoptaran. Eso no sucedió y probablemente nunca sucederá. Los desarrolladores no necesitan Kubernetes. Necesitan escribir código y una forma sencilla de crear, probar e implementar sus aplicaciones. No es realista esperar que los desarrolladores pasen años aprendiendo Kubernetes. Por otro lado, los operadores y administradores de sistemas necesitan Kubernetes. Les brinda todo lo que necesitan para ejecutar sistemas a escala. No obstante, los operadores también deben capacitar a los desarrolladores para que implementen sus propias aplicaciones. Necesitan capacitar a los desarrolladores proporcionando servicios en lugar de realizar implementaciones reales. Entonces, tenemos necesidades en conflicto. Kubernetes es necesario para algunos y una carga para otros. ¿Podemos satisfacer a todos? ¿Podemos tener un sistema basado en Kubernetes pero fácil de operar? ¿Podemos hacer que Kubernetes desaparezca y se convierta en un detalle de implementación ejecutándose en segundo plano? Analicemos hacia dónde se dirige Kubernetes y cómo podría verse en el futuro.",
      "type": "talk",
      "tags": [
        "Kubernetes",
        "developers"
      ],
      "level": "middle",
      "speakers": [
        "0ba89c51baf9f8542188bd750973e0767fbcaa68"
      ]
    },
    {
      "id": "60c113d33be4300877923158",
      "title": "Event-driven and serverless with Spring Cloud and Spring Native",
      "languages": [
        "eng"
      ],
      "abstract": "Applications in a microservices architecture can communicate with each other in different ways. Adopting an event-driven paradigm based on asynchronous messaging provides services a way of communicating while reducing runtime coupling. Functions are a natural way of implementing event-driven business logic in terms of suppliers, processors, and consumers. Furthermore, when going serverless, we aim at executables with instant startup and efficiency. Enter Spring.\n\nSpring Cloud Function favors using the functional programming paradigm to implement your business logic and provides useful features to build data pipelines, including type conversion and function composition. Functions can be exposed through different options (like web endpoints or message channels), and adapters are available to run them on platforms like Knative, AWS Lambda, Azure Functions, and GCP Functions. Spring Cloud Stream integrates your functions with messaging systems like RabbitMQ and Kafka without requiring any change to your code. Finally, Spring Native lets you compile your applications as native executable using GraalVM and providing instant startup, instant peak performance, and reduced memory consumption. ",
      "type": "talk",
      "tags": [
        "Java",
        "Cloud",
        "Serverless",
        "Spring Boot",
        "GraalVM",
        "Spring Cloud"
      ],
      "level": "beginner",
      "speakers": [
        "19243e47c15a9592009ca961a856d0091d957ab8"
      ]
    },
    {
      "id": "60c114103be4300877923159",
      "title": "Helidon – a great MicroService framework for the cloud world!",
      "languages": [
        "eng"
      ],
      "abstract": "\nIn this talk, I will tell you about a wonderful opensource framework for writing microservices called Helidon. By using it, you can write truly tiny microservices with a minimum memory footprint and distribution size, and at the same time, with performance that is often several times higher, the of its competitors. With the help of Helidon, you can write both portable code, standardized by MicroProfile, as well as an absolutely pure reactive java code. CLI, wonderful tooling, full support for GraalVM, and at least Java version 11 will allow us to write the most productive microservices without any compromise!\n",
      "type": "talk",
      "tags": [
        "helidon",
        "microservices",
        "cloud",
        "native",
        "javaee",
        "microprofile"
      ],
      "level": "beginner",
      "speakers": [
        "67155bca8730b7491ee45017054743b97982f3fb"
      ]
    },
    {
      "id": "60c1144b3be430087792315a",
      "title": "Despliega en Kubernetes usando Dekorate",
      "languages": [
        "es"
      ],
      "abstract": "Dekorate ofrece un conjunto de herramientas para generar manifiestos Kubernetes y OpenShift mientras compilas tu aplicación. Te hará la vida más fácil porque no tienes que manipular ningún tipo de fichero JSON o YAML. Puedes usar anotaciones Java, ficheros application.properties o combinar los dos para personalizar los manifiestos. En esta sesión te enseñaré cómo desplegar fácilmente micro servicios en Kubernetes y Openshift usando Dekorate, ¡no te la pierdas!\n",
      "type": "talk",
      "tags": [
        "microservice",
        "kubernetes",
        "openshift",
        "cloud",
        "java",
        "deploy"
      ],
      "level": "middle",
      "speakers": [
        "9e90e9ceb9ba68f67332f4efc12576651ca448a3"
      ]
    },
    {
      "id": "60ca52a41fc64e0884ea9ea7",
      "title": "Kafka y Pulsar: a comparación suave",
      "languages": [
        "eng"
      ],
      "abstract": "Apache Kafka ha sido el sistema de mensajería de publicación-suscripción (pub-sub) por un tiempo. Ofrece funcionalidad para una amplia gama de casos de uso empresarial, junto con un gran ecosistema de herramientas y una comunidad dedicada. Pero últimamente, el advenedizo Apache Pulsar ha ido ganando terreno. Pulsar toma las mejores partes de Kafka y las amplía para resolver problemas que estaban fuera del alcance del diseño original de Kafka pero que últimamente están llegando a Kafka. En esta sesión, cubriremos las diferencias entre ellos, cómo elegir uno según su caso de uso y el estado de la técnica de ambos. Si está interesado en los agentes de mensajería y en cómo funcionan bajo el capó, esta sesión es para usted.",
      "type": "talk",
      "tags": [
        "kafka",
        "pulsar",
        "cloud",
        "streaming",
        "events"
      ],
      "level": "middle",
      "speakers": [
        "2b14d512d954c54d2bce56f69c2a7e1b755bee2f"
      ]
    },
    {
      "id": "60ca55081fc64e0884ea9ea8",
      "title": "Preparándonos para un mundo multi-cloud",
      "languages": [
        "es"
      ],
      "abstract": "Si eres un desarrollador Cloud Native tarde o temprano algún Product Manager te preguntara:  'Pero esto se puede instalar en AWS y en Azure y en GCP? ' Seguido por:  'Tenemos un cliente que quiere lo mismo pero On-Premises '. Esta charla se enfoca en herramientas que apuntan a simplificar el desarrollo, despliegue y mantenimiento de aplicaciones cloud native construyendo funcionalidad sobre las APIs de Kubernetes. Esta charla muestra un ejemplo que la audiencia puede instalar en sus propios clusters de cómo estas herramientas pueden usarse en conjunto. Los siguientes proyectos serán explicados y demostrados: Knative, Crossplane, Helm, Tekton y CloudEvents.",
      "type": "talk",
      "tags": [
        "kubernetes",
        "cloud",
        "multi-cloud",
        "API",
        "java"
      ],
      "level": "middle",
      "speakers": [
        "4b26a098aafaf6bc3d533389b61d3ef5ab01f5a3"
      ]
    },
    {
      "id": "60d0d8351fc64e0884ea9ee7",
      "title": "IntelliJ IDEA and Keeping Pace with the New Java Language Features",
      "languages": [
        "eng"
      ],
      "abstract": "With IntelliJ IDEA's 4-month release cycle, JetBrains has adapted well to Java's 6-month release cycle. Up-to-date support for new language features in the IDE ensures that it's always easy for developers to play with the new features. IntelliJ IDEA adapts its existing set of inspections and code assistance tools so that they correctly interact with the new features and make use of them when appropriate. \n\nIn this live-coded session, the audience will take away why, how, and where to use the new language features in Java like Records, Sealed Classes, Pattern Matching, Text Blocks, Switch Expressions, and much more that will transform your everyday coding experience. You’ll see for yourself if it is worthwhile adopting all these new features.\n",
      "type": "talk",
      "tags": [
        "Java",
        "Java 12",
        "Java 14",
        "Java 14",
        "Java 15",
        "Java 16",
        "Java 17"
      ],
      "level": "middle",
      "speakers": [
        "c8d8d78afac8134e58563c75bc7c77400e6fc867"
      ]
    },
    {
      "id": "60d0d8961fc64e0884ea9ee8",
      "title": "Replicating production on your laptop using the magic of containers",
      "languages": [
        "eng"
      ],
      "abstract": "Containers are an amazing technology that are revolutionising how we deploy and create applications. Docker and Kubernetes are helping developers and organisations realise the magical potential that container technology and orchestration offer. Enter MicroShed and the Testcontainers framework enabling local test automation that leverages that magical portability containers offer. In this session we'll explore how Testcontainers can help you run and test with true-to-production environments in development with minimal re-writing of your test code.",
      "type": "talk",
      "tags": [
        "Testing",
        "Java",
        "Testcontainers",
        "MicroShed testing",
        "containers",
        "cloud",
        "cloud-native"
      ],
      "level": "middle",
      "speakers": [
        "b21e540e924111f0e9d271ed82350fa020b9972e"
      ]
    },
    {
      "id": "60d0d9ad1fc64e0884ea9ee9",
      "title": "Techniques for maintainable Quarkus Applications",
      "languages": [
        "eng"
      ],
      "abstract": "Over time, different people will work on a distributed system to maintain its current behavior and adapt the solution to new use cases; all these team members should work productively. Join this session to find out some techniques to calm those noisy loggers, avoid memory leaks, or have better control over your endpoints' response time; all these crafted to effectively maintain your Quarkus baked microservices.",
      "type": "talk",
      "tags": [
        "Quarkus",
        "Java",
        "Development Practices"
      ],
      "level": "middle",
      "speakers": [
        "959143ffd6c954e5e544cdce71383429895e3679"
      ]
    },
    {
      "id": "60d0dbbb1fc64e0884ea9eea",
      "title": "Exploring Stateful Microservices in the Cloud Native World",
      "languages": [
        "eng"
      ],
      "abstract": "How does one choose to architect a system that has a Microservice / REST API endpoints? There are many solutions out there. Some are better than others. Should state be held in a server side component, or externally? Generally we are told this is not a good practice for a Cloud Native system, when the 12-factor guidelines seem to be all about stateless containers, but is it? It’s unclear and this confusion may lead to poor technology stack choices that are impossible or extremely hard to change later on as your system evolves in terms of demand and performance.\n\nWhile stateless systems are easier to work with, the reality is that we live in a stateful world, so we have to handle the state of data accordingly to ensure data integrity beyond securing it.\n\nWe will examine and demonstrate the fundamentals of a Cloud Native system with Stateful Microservices that’s built with Open Liberty in Kubernetes:\n\n* Microservices/REST API – Options to use when running your apps in the JVM\n\n* Concurrency – how to take advantage of multi-core CPUs and clustered distributed systems\n\n* Stateful vs Stateless - while stateless apps are easier to implement, the bulk of the apps in production are stateful which involve a higher level of complexity and risk, especially when data would need to travel across multiple machine and network boundaries.  We will examine the Saga and Long-Running Action programming pattern with a prototype design.\n\n* Deployment – how about containerization and orchestration using Kubernetes?  We will look at StatefulSets and PersistenVolume from the container infrastructure perspective.\n",
      "type": "talk",
      "tags": [
        "Microservices",
        "Cloud Native",
        "Java",
        "Transactions",
        "Containers"
      ],
      "level": "beginner",
      "speakers": [
        "443a683fa84a77151521434bf96a7a082d29d361"
      ]
    },
    {
      "id": "60d0df511fc64e0884ea9eeb",
      "title": "Orchestrating Robot Swarms with Java",
      "languages": [
        "eng"
      ],
      "abstract": "At Ocado Technology, we are heavily invested in Java. We are using this language in our in-house built, end-to-end platform Ocado Smart Platform (OSP), from ecommerce to bots fulfilling customer orders and routing deliveries to homes. OSP is the world’s most advanced end-to-end eCommerce, logistics and fulfilment platform ever developed for online grocery, used by some of the world’s most forward-thinking grocery retailers across the globe.\n\nOur highly automated fulfilment centre enlist thousands of bots to process hundreds of thousands of orders per week.\n\nIn this session, we will uncover Java’s role in orchestrating these huge bot swarms for superior efficiencies of scale and explore some of the benefits and challenges that the use of Java has presented. A common question we get asked (and ask ourselves!) is why Java instead of others, like C++ or Rust, for example. In this talk, we will explore the four main reasons behind this decision: \n\n- Performance\n- Speed of development\n- Evolving platform\n- Recruitment",
      "type": "talk",
      "tags": [
        "Java",
        "design",
        "CI",
        "testing"
      ],
      "level": "beginner",
      "speakers": [
        "9b37a2375ddf8d4691a37454adec0cfebcb5153a"
      ]
    },
    {
      "id": "60d0e08b1fc64e0884ea9eec",
      "title": "Construyendo aplicaciones monolíticas que puedan escalar a micro servicios",
      "languages": [
        "eng"
      ],
      "abstract": "Es fácil en estos días caer en la trampa de comenzar a diseñar toda su aplicación con una arquitectura de micro servicios ... Porque, ya sabes, eso es lo que todo el mundo está haciendo, ¿verdad? Pero no, no. No voy a negar que los micro servicios tienen sus ventajas, específicamente en un mundo distribuido y escalable como el que tenemos que enfrentar. El problema puede estar en el enfoque que estamos adoptando. ¿Estamos considerando la arquitectura de micro servicios como un objetivo o como un medio para lograr un propósito? En esta charla pensaremos en un enfoque diferente: volveremos a lo básico y veremos cómo seguir las prácticas de DDD, CQRS y Event-Sourcing impulsará el diseño y la evolución de nuestra aplicación de tal manera que comenzaremos con un monolito pero tendremos la capacidad de escalar a una arquitectura de micro servicios más o menos fácilmente cuando (y lo que es más importante: si) lo necesitemos.",
      "type": "talk",
      "tags": [
        "DDD",
        "CQRS",
        "Event-Sourcing",
        "Microservices",
        "LocationTransparency",
        "Design"
      ],
      "level": "middle",
      "speakers": [
        "5078494b5b849a1474ce3ec801d23b06cffa5e20"
      ]
    },
    {
      "id": "60d0e0b01fc64e0884ea9eed",
      "title": "Do We Really Do Functional Programming in Java?",
      "languages": [
        "eng"
      ],
      "abstract": "Many developers believe that Functional Programming (FP) arrived in Java 8, with the addition of the Streams API. But is this really true? In this talk, Ben Evans will talk about what FP really is, and examine whether Java is really FP or not - and consider some possibilities of how we could have done things differently, in another world. ",
      "type": "talk",
      "tags": [
        "Java",
        "Functional Programming"
      ],
      "level": "advanced",
      "speakers": [
        "6d4ec093aeee2a5dde4bbce8e9698776ce7bd5b8"
      ]
    },
    {
      "id": "60d0e1a51fc64e0884ea9eee",
      "title": "Functional microservices with Kotlin",
      "languages": [
        "eng"
      ],
      "abstract": "We all heard good things about functional programming and saw small code snippets on how we can apply concepts from it, but what happens when we try to build an actual microservice?\n\nThis talk is going to introduce some of the base concepts that we are going to use, along with different approaches for each of them with their pros and cons, then we are going to use them to build a real microservice. Based on the services built in Zopa, N26, Mojira and Dynatrace",
      "type": "talk",
      "tags": [
        "Kotlin",
        "Microservices",
        "Functional Programming"
      ],
      "level": "middle",
      "speakers": [
        "f3572dc7d443088b08e41c3c094c425dc6d7d0d7"
      ]
    },
    {
      "id": "60d0e55a1fc64e0884ea9eef",
      "title": "From Imperative to Reactive",
      "languages": [
        "eng"
      ],
      "abstract": "The Reactive Programming model is complex to master. It requires a lot of experience to feel comfortable with its API. However, there’s no denying that it fits the cloud ecosystem perfectly. Since on-premises infrastructure is oversized, running a program that executes a couple of additional CPU cycles won’t change anything. On the other hand, you will pay for them if you host the same program on third-party infrastructure. Depending on the number of those cycles, and the number of nodes the program runs on, it can make a huge difference in your monthly bill.\n\nIn this demo-based talk, I’ll show how to migrate a traditional Spring Boot application that uses WebMVC, Spring Data JPA, and Spring Cache to its Reactive equivalent in a step-by-step process.",
      "type": "talk",
      "tags": [
        "reactive programming",
        "spring boot"
      ],
      "level": "beginner",
      "speakers": [
        "a0fa74f04ff057c970f863cf2b2050b7ce55e4de"
      ]
    },
    {
      "id": "60d0e6c61fc64e0884ea9ef0",
      "title": "`Huh?` to `Aha!`: A Refactoring Story",
      "languages": [
        "eng"
      ],
      "abstract": "'Entropy is the price of a Structure '. But sometimes, the price turns too high to pay. Is your codebase turning untestable, unreadable, and unmaintainable? Does your costs to add new features aren't meeting the ROIs. It's time to ask your manager to fund **Refactoring**!\n    - In this demo-driven talk, using a real-world service, we shall identity some common reasons for a codebase to rot and how to weed them out using principles from **Clean Architecture** and **Functional Programming**, along with achieving 95% test coverage and ~50% reduction in [Cognitive complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf).",
      "type": "talk",
      "tags": [
        "Java",
        "Refactoring",
        "Clean Code",
        "Functional Programming"
      ],
      "level": "beginner",
      "speakers": [
        "fb4fc6057fcdc50798fa601ea43883688923960d"
      ]
    },
    {
      "id": "60d0e6ee1fc64e0884ea9ef1",
      "title": "Fault Tolerance: Elige tu jugador",
      "languages": [
        "es"
      ],
      "abstract": "Tus micro servicios van a fallar, y esto es inevitable.\nLas estrategias de Fault Tolerance permiten create micro servicios resistentes a fallos y aislar los clients de los errores.\nExisten docenas de implementaciones para los patrones de Fault Tolerance, pero cual deberíamos elegir? Cuales son las fortalezas y las debilidades de cada implementación?\nEn esta charla, vas a presenciar un combate entre las dos grandes families de implementaciones de Fault Tolerance, representadas por dos grandes maestros: Istio y Quarkus.",
      "type": "talk",
      "tags": [
        "Microservices",
        "Fault Tolerance",
        "Resilience",
        "Java"
      ],
      "level": "middle",
      "speakers": [
        "a3ffcd525f7fe71fc93768fa166a299ec1b60ebc"
      ]
    }
  ]
}
